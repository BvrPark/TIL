> 이 글은 김영한님의 [스프링 핵심 원리- 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard) 강의의 일부분에서 요약한 것입니다.

## 컨테이너에 등록된 빈 조회
### 스프링 컨테이너에 실제 스프링 빈들이 잘 등록되었는지 확인
```java
AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);

@Test
@DisplayName("모든 빈 출력")
void 메서드(){
    String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            Object bean = ac.getBean(beanDefinitionName);
            System.out.println("name = " + beanDefinitionName + "object = "+bean);
}
```
- 내가 등록한 빈 외에도 스프링 자체에 있는 빈들도 다 출력됨.
- `ac.getBeanDefinitionNames()` : 스프링에 등록된 모든 빈 이름을 조회
- `ac.getBean()` : 빈(Bean) 이름으로 빈(Bean) 객체를 조회
</br></br>

```java
@Test
    @DisplayName("애플리케이션 빈 출력하기")
    void 메서드(){
        String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);

            
            if(beanDefinition.getRole() ==BeanDefinition.ROLE_APPLICATION){
                Object bean = ac.getBean(beanDefinitionName);
                System.out.println("name = " + beanDefinitionName + "object = "+bean);
            }

        }
    }
```
- 내가 등록한 빈(Bean)들을 조회할 때
- `ac.getBeanDefinition()` : 빈(Bean)에 하나하나에 대한 메타 데이터 정보
- `if(beanDefinition.getRole() ==BeanDefinition.ROLE_APPLICATION)`
    - 내가 직접 등록한 빈
- `if(beanDefinition.getRole() ==BeanDefinition.ROLE_INFRASTRUCTURE)`
    - 스프링이 내부에서 사용하는 빈
</br></br>

```java
@Test
    @DisplayName("빈 이름으로 조회")
    void 메서드(){
        MemberService memberService = ac.getBean("memberService", MemberService.class);
        assertThat(memberService).isInstanceOf(MemberService.class);

    }
```
- 빈(Bean) 이름과 타입으로 조회를 하는 것
- `ac.getBean()`에서 이름 없이 타입으로만으로도 조회가 가능</br>
단, 같은 타입이 여러 개면 곤란해짐
- `assertThat(memberService).isInstanceOf(MemberService.class);`
    - 조회한 빈(Bean)의 객체가 MemberService.class가 맞는지 판별
</br></br>

```java
 @Test
    @DisplayName("빈 이름으로 조회X")
    void 메서드(){
        assertThrows(NoSuchBeanDefinitionException.class,
                ()-> ac.getBean("XXXX", MemberService.class));
    }
```
- **`assertThrows(NoSuchBeanDefinitionException.class,
                ()-> ac.getBean("XXXX", MemberService.class));`**
    - **`()-> ac.getBean("XXXX", MemberService.class)`**
    - 빈(Bean)이름에 없는 XXXX를 조회하는 `ac.getBean()`이 실행되었을 때,

    - **`NoSuchBeanDefinitionException.class`** : 이러한 형식의 예외가 나타나면

    - **`assertThrows()`** : 이것은 참이 된다.

- **`NoUniqueBeanDefinitionException.class`**
    - 이 예외는 타입으로 조회시 같은 타입이 둘 이상 있을 경우, 중복오류가 발생하는 예외이다.
    - 이 예외가 발생시, 빈(Bean) 이름과 타입을 지정해서 조회를 하면 된다.
</br></br>

```java
@Test
    @DisplayName("특정 타입을 모두 조회하기")
    void 메서드(){
        Map<String, MemberRepository> beansOfType = ac.getBeansOfType(MemberRepository.class);
        for (String key : beansOfType.keySet()) {
            System.out.println("key = " + key + "value = " + beansOfType.get(key));
        }
        System.out.println("beansOfType = " + beansOfType);
        assertThat(beansOfType.size()).isEqualTo(2);
    }
```
- 특정 타입을 조회할 때는 `getBeansOfType()`을 쓰면 된다.
- `assertThat(beansOfType.size()).isEqualTo(2);`
    - 특정 타입이 2개가 맞는지 판별하는 것
    - `isEqualTo(3)`이면 3개가 맞는지 판별하는 것
</br></br>

상속관계 일땐 부모 타입으로 조회를 하면 자식 타입도 함께 조회된다.</br>
그래서 Object타입으로 조회를 하면 모든 스프링 빈을 조회한다.
